const puppeteer = require('puppeteer');
const algoliasearch = require('algoliasearch');

const BASE_URL = process.env.SITE_URL || 'https://docs.redpanda.com';
const DOC_PATHS = [
  '/api/doc/admin/',
  '/api/doc/http-proxy/',
  '/api/doc/schema-registry/',
  '/api/doc/cloud-controlplane/',
  '/api/doc/cloud-dataplane/',
];

// Check for required environment variables
const ALGOLIA_APP_ID = process.env.ALGOLIA_APP_ID;
const ALGOLIA_ADMIN_API_KEY = process.env.ALGOLIA_ADMIN_API_KEY;
const ALGOLIA_INDEX_NAME = process.env.ALGOLIA_INDEX_NAME || 'docs';

if (!ALGOLIA_APP_ID || !ALGOLIA_ADMIN_API_KEY) {
  console.log('Algolia configuration is missing. Set ALGOLIA_APP_ID, ALGOLIA_ADMIN_API_KEY, and ALGOLIA_INDEX_NAME environment variables.');
  process.exit(1);
}

const client = algoliasearch(ALGOLIA_APP_ID, ALGOLIA_ADMIN_API_KEY);
const index = client.initIndex(ALGOLIA_INDEX_NAME);

async function scrapeAndIndex() {
  const browser = await puppeteer.launch({
  headless: 'new',
  args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  const allRecords = [];

  for (const path of DOC_PATHS) {
    const url = `${BASE_URL}${path}`;
    console.log(`\nüîç Processing: ${url}`);
    
    const page = await browser.newPage();
    try {
      await page.goto(url, { waitUntil: 'networkidle0' });
      // Wait for initial page load - some content may still be lazy-loading
      await page.waitForTimeout(3000);

      /* 
       * Understanding Bump.sh's turbo-frame architecture
       * 
       * The Redpanda API documentation is generated by Bump.sh, which uses Hotwire Turbo Frames
       * for lazy-loading content. This creates a significant challenge for web scraping.
       * 
       * Turbo-frame lazy loading problem:
       * Each API endpoint is wrapped in a <turbo-frame id="operation-xxx"> element with a 
       * loading="lazy" attribute. This means frames don't load content initially - only the 
       * first visible frame loads immediately while others remain empty shells. When we query 
       * the DOM directly, we get empty frames with no method or path information.
       * 
       * Initial approach and limitations:
       * Early versions attempted to extract data directly from the main page, which resulted 
       * in 240+ endpoints showing method="UNKNOWN" and path="UNKNOWN". Only API groups worked 
       * because they're not lazy-loaded.
       * 
       * The solution - individual frame navigation:
       * Each turbo-frame has a 'src' attribute pointing to its individual content URL.
       * For example: src="https://docs.redpanda.com/api/doc/admin/operation/operation-get_brokers"
       * By navigating directly to these URLs, we get fully-loaded HTML with all data,
       * allowing us to extract method (.operation-verb) and path (.operation-path) information.
       * 
       * Why this approach works:
       * Individual frame URLs contain complete, non-lazy-loaded content where all CSS selectors
       * work properly. This enables extraction of HTTP method, API path, title, description, 
       * and other metadata. The success rate improved from 16% to 100% using this method.
       */

      // Get page metadata and collect turbo-frame URLs for individual processing
      const pageInfo = await page.evaluate(() => {
        const basePath = window.location.pathname;
        const latestVersion = document.querySelector('meta[name="latest-redpanda-version"]')?.getAttribute('content');
        const isCloudAPI = basePath.includes('/cloud-');
        const product = isCloudAPI ? 'Cloud' : 'Self-Managed';

        // Step 1: Collect API groups
        // Groups load immediately and don't require special handling
        const groupElements = document.querySelectorAll('turbo-frame[id^="endpoint-"]');
        const groups = Array.from(groupElements).map(element => {
          const groupId = element.id;
          if (!groupId || !groupId.startsWith('endpoint-')) return null;

          let title = groupId.replace('endpoint-', '').replace(/[-_]/g, ' ')
            .replace(/\b\w/g, l => l.toUpperCase());

          const urlPath = `/api/doc/${basePath.split('/').filter(Boolean).pop()}/group/${groupId}`;

          const groupRecord = {
            objectID: urlPath,
            product,
            type: 'API Group',
            title: title,
            description: `API endpoints for ${title}`,
            url: `${location.origin}${urlPath}`,
            _tags: isCloudAPI ? ['Cloud'] : [`Self-Managed v${latestVersion}`],
            _source: basePath
          };

          if (!isCloudAPI) {
            groupRecord.version = latestVersion;
          }

          return groupRecord;
        }).filter(Boolean);

        /* 
         * Step 2: Extract turbo-frame source URLs for API operations
         * 
         * This is the key insight that solved the lazy-loading problem.
         * 
         * The problem: Direct DOM querying fails because turbo-frames are empty shells.
         * When we have <turbo-frame id="operation-get_brokers" loading="lazy" src="...">, 
         * the frame has no content initially. Attempting to find .operation-verb or 
         * .operation-path returns null, resulting in method="UNKNOWN" and path="UNKNOWN" 
         * for all endpoints.
         * 
         * The solution: Extract the 'src' attribute and navigate to it individually.
         * Each frame has a src attribute like:
         * src="https://docs.redpanda.com/api/doc/admin/operation/operation-get_brokers"
         * 
         * This URL contains the complete, fully-loaded endpoint documentation. By visiting 
         * this URL directly, we bypass the lazy-loading mechanism entirely.
         * 
         * Technical implementation:
         * We collect all operation turbo-frames from the main page, extract their 'src' 
         * attribute (the individual endpoint URL), and store the operationId + src for 
         * later individual processing. This approach scales efficiently to hundreds of endpoints.
         */
        const operationElements = document.querySelectorAll('turbo-frame[id^="operation-"]');
        const frameUrls = Array.from(operationElements).map(element => {
          const operationId = element.id;
          const src = element.getAttribute('src');
          
          // Both operationId and src are required for successful extraction
          if (operationId && src) {
            return { operationId, src };
          }
          return null;
        }).filter(Boolean);

        return { 
          basePath, 
          latestVersion, 
          isCloudAPI, 
          product, 
          groups,
          frameUrls
        };
      });

      console.log(`üìÑ Found ${pageInfo.groups.length} groups and ${pageInfo.frameUrls.length} operations`);

      // Add groups to records (these don't need special processing)
      allRecords.push(...pageInfo.groups);

      /* 
       * Step 3: Process each operation frame individually
       * 
       * This is where we navigate to each turbo-frame's src URL to extract complete 
       * endpoint data that isn't available on the main page.
       * 
       * Why individual navigation is necessary:
       * 
       * Lazy loading bypass: The main page contains <turbo-frame loading="lazy"> elements 
       * with empty content, while individual URLs contain full HTML with method, path, 
       * description, and examples.
       * 
       * Complete data extraction: Individual pages contain fully loaded elements where
       * .operation-verb contains the HTTP method (GET, POST, DELETE, etc.), .operation-path 
       * contains the API endpoint (/v1/brokers, /v1/topics, etc.), and headers, descriptions, 
       * and examples are all accessible.
       * 
       * Performance considerations: Each frame navigation adds approximately 1-2 seconds 
       * per endpoint. For 240 endpoints, total processing time is around 6-8 minutes. 
       * However, this is the only reliable way to get accurate, complete data. Alternative 
       * approaches like scrolling or waiting don't consistently trigger frame loading.
       * 
       * Error handling: Some frames may fail to load due to network issues or timeouts.
       * When this happens, we create a fallback record with an operationId-derived title
       * to ensure no endpoints are lost due to temporary failures.
       */

      // Process each operation frame individually
      let successCount = 0;
      let errorCount = 0;
      
      for (const frameInfo of pageInfo.frameUrls) {
        // Create a new page for each frame to avoid cross-contamination
        const framePage = await browser.newPage();
        try {
          /* 
           * Individual frame navigation - the core solution
           * 
           * Navigate directly to the turbo-frame's src URL to get complete content.
           * 
           * Example transformation:
           * Main page: <turbo-frame id="operation-get_brokers" src="..."> [EMPTY]
           * Frame URL: https://docs.redpanda.com/api/doc/admin/operation/operation-get_brokers
           * Result: Full HTML with method="GET", path="/v1/brokers", complete documentation
           * 
           * This approach bypasses Turbo's lazy-loading and provides access to the complete 
           * DOM structure with all CSS classes, actual HTTP method and API path, full 
           * descriptions, parameters, response examples, and everything needed for 
           * high-quality search indexing.
           */
          await framePage.goto(frameInfo.src, { 
            waitUntil: 'networkidle0',
            timeout: 30000 
          });
          
          /* 
           * Extract complete endpoint data
           * 
           * Now that we have the fully-loaded frame content, we can extract all the data 
           * that was missing from the lazy-loaded main page.
           * 
           * Key selectors (discovered through DOM inspection):
           * - .operation-verb: Contains HTTP method (GET, POST, PUT, DELETE, PATCH)
           * - .operation-path: Contains API endpoint path (/v1/brokers, /v1/topics/{topic}/partitions)
           * - h2, .operation-title: Contains human-readable endpoint title
           * - .markdown-content.flow p: Contains endpoint description (always sibling of h2 operation-title)
           * 
           * Fallback behavior:
           * - If title is missing, we generate one from operationId (operation-get_brokers ‚Üí "Get Brokers")
           * - If method/path is missing, we mark as 'UNKNOWN' for validation and debugging purposes
           */
          const operationDetails = await framePage.evaluate((frameInfo, pageInfo) => {
            const operationId = frameInfo.operationId;
            
            let method = '';
            let path = '';
            let title = '';
            let description = '';

            // Extract method and path from loaded frame
            const methodEl = document.querySelector('.operation-verb, .http-method, .method, [class*="verb"], [class*="method"]');
            if (methodEl) method = methodEl.textContent?.trim();

            const pathEl = document.querySelector('.operation-path, .api-path, .path, [class*="path"]');
            if (pathEl) path = pathEl.textContent?.trim();

            const titleEl = document.querySelector('h2, h3, .operation-title, .title, [class*="title"]');
            if (titleEl) title = titleEl.textContent?.trim();

            // Description is always a sibling of the h2 operation-title with class "markdown-content flow"
            const descEl = document.querySelector('.markdown-content.flow p');
            if (descEl) description = descEl.textContent?.trim();

            // Fallback: generate title from operation ID
            if (!title) {
              title = operationId.replace('operation-', '').replace(/_/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
            }

            const urlPath = `/api/doc/${pageInfo.basePath.split('/').filter(Boolean).pop()}/operation/${operationId}`;

            const operationRecord = {
              objectID: urlPath,
              product: pageInfo.product,
              type: 'API Endpoint',
              method: method || 'UNKNOWN',
              path: path || 'UNKNOWN',
              title: title,
              description: description || `API endpoint: ${title}`,
              url: `${location.origin}${urlPath}`,
              _tags: pageInfo.isCloudAPI ? ['Cloud'] : [`Self-Managed v${pageInfo.latestVersion}`],
              _source: pageInfo.basePath
            };

            if (!pageInfo.isCloudAPI) {
              operationRecord.version = pageInfo.latestVersion;
            }

            return operationRecord;
          }, frameInfo, pageInfo);
          
          allRecords.push(operationDetails);
          successCount++;
          
        } catch (err) {
          console.error(`‚ö†Ô∏è  Error processing ${frameInfo.operationId}: ${err.message}`);
          errorCount++;
          
          // Create fallback record
          const urlPath = `/api/doc/${pageInfo.basePath.split('/').filter(Boolean).pop()}/operation/${frameInfo.operationId}`;
          const fallbackRecord = {
            objectID: urlPath,
            product: pageInfo.product,
            type: 'API Endpoint',
            method: 'UNKNOWN',
            path: 'UNKNOWN',
            title: frameInfo.operationId.replace('operation-', '').replace(/_/g, ' ')
              .replace(/\b\w/g, l => l.toUpperCase()),
            description: `API endpoint`,
            url: `${BASE_URL}${urlPath}`,
            _tags: pageInfo.isCloudAPI ? ['Cloud'] : [`Self-Managed v${pageInfo.latestVersion}`],
            _source: pageInfo.basePath
          };
          
          if (!pageInfo.isCloudAPI) {
            fallbackRecord.version = pageInfo.latestVersion;
          }
          
          allRecords.push(fallbackRecord);
        } finally {
          await framePage.close();
        }
      }

      console.log(`‚úÖ Processed ${successCount} operations successfully, ${errorCount} with errors`);

    } catch (err) {
      console.error(`‚ùå Error processing ${url}:`, err.message);
    } finally {
      await page.close();
    }
  }

  await browser.close();

  if (allRecords.length === 0) {
    console.warn('No records to index.');
    return;
  }

  // Summary
  const summary = {
    total: allRecords.length,
    groups: allRecords.filter(r => r.type === 'API Group').length,
    endpoints: allRecords.filter(r => r.type === 'API Endpoint').length,
    withMethod: allRecords.filter(r => r.method && r.method !== 'UNKNOWN').length,
    withPath: allRecords.filter(r => r.path && r.path !== 'UNKNOWN').length,
    selfManaged: allRecords.filter(r => r.product === 'Self-Managed').length,
    cloud: allRecords.filter(r => r.product === 'Cloud').length
  };

  console.log('\nüìä EXTRACTION SUMMARY:');
  console.log(`Total records: ${summary.total}`);
  console.log(`API Groups: ${summary.groups}`);
  console.log(`API Endpoints: ${summary.endpoints}`);
  console.log(`Endpoints with method: ${summary.withMethod}/${summary.endpoints}`);
  console.log(`Endpoints with path: ${summary.withPath}/${summary.endpoints}`);
  console.log(`Self-Managed: ${summary.selfManaged}`);
  console.log(`Cloud: ${summary.cloud}`);

  // Index to Algolia
  try {
    const { objectIDs } = await index.saveObjects(allRecords);
    console.log(`\nüéâ Successfully indexed ${objectIDs.length} records to Algolia!`);

    // Verify indexing success rate
    const successRate = ((summary.withMethod / summary.endpoints) * 100).toFixed(1);
    console.log(`üìà Method extraction success rate: ${successRate}%`);
    
    if (summary.withMethod === summary.endpoints) {
      console.log('‚úÖ Perfect! All endpoints have method information.');
    } else {
      console.log(`‚ö†Ô∏è  ${summary.endpoints - summary.withMethod} endpoints missing method information.`);
    }

  } catch (err) {
    console.error(`‚ùå Failed to index to Algolia:`, err);
    process.exit(1);
  }
}

scrapeAndIndex().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
