/*
 * Redpanda API docs scraper + Algolia indexer
 * - Adds `api` field (which API an endpoint belongs to)
 * - Adds `displayTitle` (UI) and `searchTitle` (indexing-only: `${title} (${API Name})`)
 * - Creates an `API` root record per API (for generic queries like "admin api")
 * - Adds synonyms and query rules to improve recall + pin API roots for generic queries
 * - Updates index settings (searchableAttributes, attributesForFaceting, attributesToHighlight)
 */

const puppeteer = require('puppeteer');
const algoliasearch = require('algoliasearch');

// ---------- Config ----------
const BASE_URL = process.env.SITE_URL || 'https://docs.redpanda.com';
const DOC_PATHS = [
  '/api/doc/admin/',
  '/api/doc/http-proxy/',
  '/api/doc/schema-registry/',
  '/api/doc/cloud-controlplane/',
  '/api/doc/cloud-dataplane/',
];

// Human-friendly API names for each doc root
const API_NAME_BY_PATH = {
  '/api/doc/admin/': 'Admin API',
  '/api/doc/http-proxy/': 'HTTP Proxy API',
  '/api/doc/schema-registry/': 'Schema Registry API',
  '/api/doc/cloud-controlplane/': 'Cloud Control Plane API',
  '/api/doc/cloud-dataplane/': 'Cloud Data Plane API',
};

// Algolia env
const ALGOLIA_APP_ID = process.env.ALGOLIA_APP_ID;
const ALGOLIA_ADMIN_API_KEY = process.env.ALGOLIA_ADMIN_API_KEY;
const ALGOLIA_INDEX_NAME = process.env.ALGOLIA_INDEX_NAME || 'docs';

if (!ALGOLIA_APP_ID || !ALGOLIA_ADMIN_API_KEY) {
  console.log('Algolia configuration is missing. Set ALGOLIA_APP_ID, ALGOLIA_ADMIN_API_KEY, and ALGOLIA_INDEX_NAME environment variables.');
  process.exit(1);
}

const client = algoliasearch(ALGOLIA_APP_ID, ALGOLIA_ADMIN_API_KEY);
const index = client.initIndex(ALGOLIA_INDEX_NAME);

async function scrapeAndIndex() {
  const browser = await puppeteer.launch({
  headless: 'new',
  args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  const allRecords = [];
  const apiRootRecords = []; // keep track for query rules

  for (const path of DOC_PATHS) {
    const url = `${BASE_URL}${path}`;
    const apiName = API_NAME_BY_PATH[path] || path.split('/').filter(Boolean).pop();
    console.log(`\\nüîç Processing: ${url} (${apiName})`);

    const page = await browser.newPage();
    try {
      await page.goto(url, { waitUntil: 'networkidle0' });
      await page.waitForTimeout(3000);

      /*
       * Understanding Bump.sh's turbo-frame architecture
       *
       * The Redpanda API documentation is generated by Bump.sh, which uses Hotwire Turbo Frames
       * for lazy-loading content. This creates a significant challenge for web scraping.
       *
       * Turbo-frame lazy loading problem:
       * Each API endpoint is wrapped in a <turbo-frame id="operation-xxx"> element with a 
       * loading="lazy" attribute. This means frames don't load content initially - only the 
       * first visible frame loads immediately while others remain empty shells. When we query 
       * the DOM directly, we get empty frames with no method or path information.
       *
       * Initial approach and limitations:
       * Early versions attempted to extract data directly from the main page, which resulted 
       * in 240+ endpoints showing method="UNKNOWN" and path="UNKNOWN". Only API groups worked 
       * because they're not lazy-loaded.
       *
       * The solution - individual frame navigation:
       * Each turbo-frame has a 'src' attribute pointing to its individual content URL.
       * For example: src="https://docs.redpanda.com/api/doc/admin/operation/operation-get_brokers"
       * By navigating directly to these URLs, we get fully-loaded HTML with all data,
       * allowing us to extract method (.operation-verb) and path (.operation-path) information.
       *
       * Why this approach works:
       * Individual frame URLs contain complete, non-lazy-loaded content where all CSS selectors
       * work properly. This enables extraction of HTTP method, API path, title, description, 
       * and other metadata. The success rate improved from 16% to 100% using this method.
      */
      const pageInfo = await page.evaluate((apiName) => {
        const basePath = window.location.pathname; // e.g., /api/doc/admin/
        const latestVersion = document.querySelector('meta[name="latest-redpanda-version"]')?.getAttribute('content');
        const isCloudAPI = basePath.includes('/cloud-');
        const product = isCloudAPI ? 'Cloud' : 'Self-Managed';

        // --- Extract clean API title (exclude version chip), definition version, and Base URL ---
        const h1 = document.querySelector('h1.doc-section-title');
        const apiTitleText = h1?.querySelector('.anchor-link')?.childNodes?.
          /* Keep only text nodes */
          values?.() ? Array.from(h1.querySelector('.anchor-link').childNodes).filter(n => n.nodeType === Node.TEXT_NODE).map(n => n.textContent).join(' ').trim() :
          (h1?.querySelector('.anchor-link')?.textContent || '').trim();
        const apiTitle = apiTitleText || apiName;
        const apiDefinitionVersion = h1?.querySelector('.label')?.textContent?.trim() || null;

        function getApiBaseUrl() {
          const examples = Array.from(document.querySelectorAll('portal-example'));
          for (const ex of examples) {
            const title = ex.querySelector('header .title')?.textContent?.trim();
            if (title && /base url/i.test(title)) {
              const code = ex.querySelector('.example-content pre code')?.textContent?.trim();
              if (code) return code.replace(/^['\"]|['\"]$/g, '');
            }
          }
          return null;
        }
        const apiBaseUrl = getApiBaseUrl();

        // Build API root record (generic landing result)
        const firstPara = document.querySelector('main p, .markdown-content.flow p');
        const apiDesc = firstPara?.textContent?.trim() || `Endpoints for ${apiName}.`;
        const apiRoot = {
          objectID: basePath,
          product,
          api: apiName,
          type: 'API',
          title: apiTitle,
          displayTitle: apiTitle,
          searchTitle: `${apiTitle} (${apiName})`,
          description: apiDesc,
          apiBaseUrl: apiBaseUrl || undefined,
          apiDefinitionVersion: apiDefinitionVersion || undefined,
          url: `${location.origin}${basePath}`,
          _tags: [apiName],
          _source: basePath,
        };
        if (!isCloudAPI) apiRoot.version = latestVersion;

        // API groups (immediately present)
        const groupElements = document.querySelectorAll('turbo-frame[id^="endpoint-"]');
        const groups = Array.from(groupElements)
          .map((el) => {
            const id = el.id;
            if (!id || !id.startsWith('endpoint-')) return null;
            const title = id.replace('endpoint-', '').replace(/[-_]/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
            const urlPath = `/api/doc/${basePath.split('/').filter(Boolean).pop()}/group/${id}`;
            const rec = {
              objectID: urlPath,
              product,
              api: apiName,
              type: 'API Group',
              title,
              displayTitle: title,
              searchTitle: `${title} (${apiName})`,
              description: `API endpoints for ${title}`,
              apiBaseUrl: apiBaseUrl || undefined,
              url: `${location.origin}${urlPath}`,
              _tags: [apiName],
              _source: basePath,
            };
            if (!isCloudAPI) rec.version = latestVersion;
            return rec;
          })
          .filter(Boolean);

        // Collect operation frame srcs for full endpoint pages
        const operationElements = document.querySelectorAll('turbo-frame[id^="operation-"]');
        const frameUrls = Array.from(operationElements)
          .map((el) => {
            const operationId = el.id;
            const src = el.getAttribute('src');
            if (operationId && src) return { operationId, src };
            return null;
          })
          .filter(Boolean);

        return { basePath, latestVersion, isCloudAPI, product, apiName, apiRoot, groups, frameUrls };
      }, apiName);

      console.log(`üìÑ Found 1 API root, ${pageInfo.groups.length} groups and ${pageInfo.frameUrls.length} operations`);

      // Add API root + groups
      apiRootRecords.push(pageInfo.apiRoot);
      allRecords.push(pageInfo.apiRoot, ...pageInfo.groups);

      // Process each operation frame individually
      let successCount = 0;
      let errorCount = 0;

      for (const frameInfo of pageInfo.frameUrls) {
        const framePage = await browser.newPage();
        try {
          await framePage.goto(frameInfo.src, { waitUntil: 'networkidle0', timeout: 30000 });

          const operationRecord = await framePage.evaluate((frameInfo, pageInfo) => {
            const operationId = frameInfo.operationId;
            let method = '';
            let path = '';
            let title = '';
            let description = '';

            const methodEl = document.querySelector('.operation-verb, .http-method, .method, [class*="verb"], [class*="method"]');
            if (methodEl) method = methodEl.textContent?.trim();

            const pathEl = document.querySelector('.operation-path, .api-path, .path, [class*="path"]');
            if (pathEl) path = pathEl.textContent?.trim();

            const titleEl = document.querySelector('h2, h3, .operation-title, .title, [class*="title"]');
            if (titleEl) title = titleEl.textContent?.trim();

            const descEl = document.querySelector('.markdown-content.flow p');
            if (descEl) description = descEl.textContent?.trim();

            if (!title) {
              title = operationId.replace('operation-', '').replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
            }

            const urlPath = `/api/doc/${pageInfo.basePath.split('/').filter(Boolean).pop()}/operation/${operationId}`;

            const rec = {
              objectID: urlPath,
              product: pageInfo.product,
              api: pageInfo.apiName,
              type: 'API Endpoint',
              method: method || 'UNKNOWN',
              path: path || 'UNKNOWN',
              title,
              displayTitle: title,
              searchTitle: `${title} (${pageInfo.apiName})`,
              description: description || `API endpoint: ${title}`,
              apiBaseUrl: pageInfo.apiBaseUrl || undefined,
              url: `${location.origin}${urlPath}`,
              _tags: [pageInfo.apiName],
              _source: pageInfo.basePath,
            };
            if (!pageInfo.isCloudAPI) rec.version = pageInfo.latestVersion;
            return rec;
          }, frameInfo, pageInfo);

          allRecords.push(operationRecord);
          successCount++;
        } catch (err) {
          console.error(`‚ö†Ô∏è  Error processing ${frameInfo.operationId}: ${err.message}`);
          errorCount++;

          const urlPath = `/api/doc/${pageInfo.basePath.split('/').filter(Boolean).pop()}/operation/${frameInfo.operationId}`;
          const title = frameInfo.operationId.replace('operation-', '').replace(/_/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());
          const fallbackRecord = {
            objectID: urlPath,
            product: pageInfo.product,
            api: pageInfo.apiName,
            type: 'API Endpoint',
            method: 'UNKNOWN',
            path: 'UNKNOWN',
            title,
            displayTitle: title,
            searchTitle: `${title} (${pageInfo.apiName})`,
            description: 'API endpoint',
            apiBaseUrl: pageInfo.apiBaseUrl || undefined,
            url: `${BASE_URL}${urlPath}`,
            _tags: [pageInfo.apiName],
            _source: pageInfo.basePath,
          };
          if (!pageInfo.isCloudAPI) fallbackRecord.version = pageInfo.latestVersion;
          allRecords.push(fallbackRecord);
        } finally {
          await framePage.close();
        }
      }

      console.log(`‚úÖ Processed ${successCount} operations successfully, ${errorCount} with errors`);
    } catch (err) {
      console.error(`‚ùå Error processing ${url}:`, err.message);
    } finally {
      await page.close();
    }
  }

  await browser.close();

  if (allRecords.length === 0) {
    console.warn('No records to index.');
    return;
  }

  // Summary
  const TYPE_API = 'api';
  const TYPE_API_GROUP = 'api group';
  const TYPE_API_ENDPOINT = 'api endpoint';
  const PRODUCT_SELF_MANAGED = 'self-managed';
  const PRODUCT_CLOUD = 'cloud';

  // Reduce for summary stats, force lower-case for type/product
  const summary = allRecords.reduce((acc, r) => {
    const type = (r.type || '').toLowerCase();
    const product = (r.product || '').toLowerCase();
    acc.total++;
    if (type === TYPE_API_GROUP) acc.groups++;
    if (type === TYPE_API_ENDPOINT) {
      acc.endpoints++;
      if (r.method && r.method !== 'UNKNOWN') acc.withMethod++;
      if (r.path && r.path !== 'UNKNOWN') acc.withPath++;
    }
    if (product === PRODUCT_SELF_MANAGED) acc.selfManaged++;
    if (product === PRODUCT_CLOUD) acc.cloud++;
    return acc;
  }, {
    total: 0,
    apis: apiRootRecords.length,
    groups: 0,
    endpoints: 0,
    withMethod: 0,
    withPath: 0,
    selfManaged: 0,
    cloud: 0
  });

  console.log('\\nüìä EXTRACTION SUMMARY:');
  console.log(`API roots: ${summary.apis}`);
  console.log(`API groups: ${summary.groups}`);
  console.log(`API endpoints: ${summary.endpoints}`);
  console.log(`Endpoints with method: ${summary.withMethod}/${summary.endpoints}`);
  console.log(`Endpoints with path: ${summary.withPath}/${summary.endpoints}`);
  console.log(`Self-Managed: ${summary.selfManaged}`);
  console.log(`Cloud: ${summary.cloud}`);

  // Index to Algolia
  try {
    const { objectIDs } = await index.saveObjects(allRecords, { autoGenerateObjectIDIfNotExist: false });
    console.log(`\\nüéâ Successfully indexed ${objectIDs.length} records to Algolia!`);
  } catch (err) {
    console.error('‚ùå Failed to index to Algolia:', err);
    process.exit(1);
  }

  // Configure index for better recall + generic queries
  await configureIndex(index, apiRootRecords);
}

/**
 * Configure Algolia index settings, synonyms, and query rules.
 * - Adds `api` as searchable + facetable
 * - Adds synonyms like "admin api" ‚Üî "Admin API"
 * - Adds rules to pin API root records when users search "<api> api"
 */
async function configureIndex(index, apiRootRecords) {
  console.log('\\nüõ†  Updating index settings, synonyms, and rules...');

  // Settings
  await index.setSettings({
    searchableAttributes: [
      'unordered(searchTitle)',  // indexing-only helper
      'unordered(title)',
      'unordered(path)',
      'unordered(method)',
      'unordered(description)',
      'unordered(api)',
      'unordered(product)',
      'unordered(version)',
    ],
    attributesForFaceting: [
      'searchable(_tags)',
      'searchable(type)',
      'searchable(product)',
      'searchable(api)',
      'searchable(version)',
    ],
    ignorePlurals: true,
    removeWordsIfNoResults: 'allOptional',
  });


  // Synonyms ("admin api" ‚Üî "Admin API", etc.)
  const synonyms = Object.entries(API_NAME_BY_PATH).map(([path, apiName]) => {
    const slug = apiName.toLowerCase().replace(/\s+/g, '-').replace(/[^A-Za-z0-9_-]/g, '');
    const variants = [
      apiName,
      apiName.replace(/ api$/i, ''), // "Admin"
      `${apiName} docs`,
      `${apiName} endpoints`,
      `${apiName} reference`,
      apiName.toLowerCase(),
      apiName.toLowerCase().replace(/ api$/, ''),
      `${apiName.toLowerCase()} docs`,
      `${apiName.toLowerCase()} endpoints`,
      `${apiName.toLowerCase()} reference`,
      apiName.toLowerCase().replace(/\s+/g, '-'), // admin-api
      `${apiName.toLowerCase().replace(/\s+/g, '-')} docs`,
    ];
    return { objectID: `syn_${slug}`, type: 'synonym', synonyms: Array.from(new Set(variants)) };
  });
  await index.saveSynonyms(synonyms, { replaceExistingSynonyms: false });

  console.log('‚úÖ Index configured.');
}

scrapeAndIndex().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});